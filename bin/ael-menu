#! /usr/bin/env python
# :----------------------------------------------------------------------- INFO
# :[bin/ael-menu]
# :author        : fantomH @alterEGO Linux
# :created       : 2023-08-08 14:40:10 UTC
# :updated       : 2025-02-19 12:16:13 UTC
# :description   : Application launcher using `fzf` and `tmux`

import argparse
from collections import namedtuple
import os
import tomllib
import random
import shutil
import subprocess
import sys
import textwrap
from time import sleep

def show_documentation() -> None:
    """Display detailed documentation and exit."""

    documentation = textwrap.dedent("""
    ael-menu documentation
    ======================

    The ael-menu is part of the AlterEgo Linux project.

    It's main purpose is to launch applications and run functionalities configured in TOML files.

    The main configuration file `~/.ael/ael-menu/ael-menu.toml` is generated by the AlterEgo Linux team. This file will be overwritten by any updates.

    User specific options should be added to ~/.ael/ael-menu/ael-menu-extra.toml.

    Configuration file(s)
    ---------------------

    Entries in the TOML file are as follow.
    
    ```
    [app.waypaper]
    name             = "wallpaper (waypaper)"
    run              = "launch_gui"
    cmd              = "waypaper"
    which            = ["waypaper", "swww"]
    session          = "null"
    description      = "Set up wallpaper."
    desktop          = ["Hyprland"]
    is_floating      = true
    ```
    Subsections of the "app" table must be unique. Thus, you cannot have "[app.waypaper] twice. In this case, you must name the subsection differently, like "[app.waypaper]" and "[app.waypaper2]".    

    The menu will display the value of the keys name and description.

    TOML Keys
    ---------

    name: Application name to display on the menu (ex. "wallpaper (waypaper)").

    run: How will the command (`cmd`) will be launched. Values are the following.

        - execute:
            Execute a command and exit.

        - launch_gui:
            Launch GUI application.
            This will ensure that the application is detached from the terminal and remain open.

        - launch_tui:
            Launch TUI application in a terminal and exit when quitting the TUI.

        - stay_in_terminal:
            Execute a command in a tmux session, in order to remain in the terminal.

    cmd: Command to be run. It should run as intended if the proper `run` option is choosen. For complex commands, it is recommanded to create a script and launch that script instead.

    which: A Python style list of application. While building the menu entries, it will make sure that all applications in the list are installed. This prevent the menu to display an entry that cannot launch. If no application needs to be verified, the `which` key must have an empty list (which = []).

    session: A string used as a prefix to name the TMUX session when needed by the `run` option. This can be any alphanumeric one-word string. It is recommanded to use descriptive string like "FIREFOX" or "TMUX". Do not leave empty, use "null" instead.

    description: A description displayed on ael-menu.

    desktop: List of desktop environments or window managers. While building the menu entries, options will be filtered by checking if the environment variable `XDG_CURRENT_DESKTOP` is in the `desktop` list. As of now, AlterEgo Linux only uses Hyprland window manager, but options could be Gnome, i3wm, sway, etc, as long as it matches `XDG_CURRENT_DESKTOP`. The value is not case sensitive. 

    is_floating: Not implemented yet. This should, in the future, allow certain apps to open in a floating window, controlled from the menu configuration.

    Running ael-menu
    ----------------

    ael-menu is built around fzf and the standard Python libraries, to ensure it can be used almost everywhere. You can run the menu in the TTY, in the terminal or as a pseudo-GUI by adding few lines in hyprland.config:

    ```
    bind = $mainMod, M, exec, alacritty -t "AEL Menu" -e "ael-menu"
    windowrulev2 = float, title:(.*)(AEL Menu)(.*)
    ```

    """)

    print(documentation)
    sys.exit(0)

def get_desktop_environment() -> str:
    """
    Return the desktop environment (Hyprland, Gnome, etc.) as DESKTOP or TTY.
    """

    if os.getenv('XDG_CURRENT_DESKTOP'):
        return os.getenv('XDG_CURRENT_DESKTOP')
    elif os.getenv('XDG_SESSION_TYPE'):
        return os.getenv('XDG_SESSION_TYPE')

def which(exec_list: list) -> bool:
    """Check if needed applications are installed."""

    return all(shutil.which(e) is not None for e in exec_list)

# :----------/ OPTIONS

def load_configuration(file_path: str, desktop: str) -> list:
    """Load TOML configuration and return a list of MenuOption."""

    if not os.path.exists(file_path):
        return []
    
    with open(file_path, 'rb') as _input:
        data = tomllib.load(_input)

    MenuOption = namedtuple('MenuOption', ['name', 'run', 'cmd', 'which', 'session', 'description', 'desktop', 'is_floating'])
    
    return [
        MenuOption(**values) 
        for values in data.get('app', {}).values() 
        if desktop.lower() in map(str.lower, values['desktop']) and which(values['which'])
    ]

def generate_options() -> list:
    """Generate menu options from TOML configuration files."""

    config_dir = os.path.join(os.path.expanduser('~'), '.ael', 'ael-menu')
    main_config = os.path.join(config_dir, 'ael-menu.toml')
    extra_config = os.path.join(config_dir, 'ael-menu-extra.toml')

    global DESKTOP
    DESKTOP = get_desktop_environment()

    options = load_configuration(main_config, DESKTOP)
    options += load_configuration(extra_config, DESKTOP)

    return sorted(options, key=lambda o: o.name.lower())

# :----------/ MENU

def run_menu(entries: bytes) -> str | None:

    menu = subprocess.run(['fzf', 
                        "--color=gutter:-1",
                        "--margin=4%",
                        "--border=none",
                        "--prompt=LAUNCH ❯ ",
                        "--header= ",
                        "--no-hscroll",
                        "--reverse",
                        "-i",
                        "--exact",
                        "--tiebreak=begin",
                        "--no-info",
                        "--pointer=•",
                        ], input=entries, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)

    return menu.stdout.decode('UTF-8').strip().split('  ')[0] if menu.stdout else None

# :----------/ MODES

def execute(command: str) -> None:
    """Execute command and exit."""

    subprocess.run(f"{command}", shell=True)

def launch_gui(session: str, command: str) -> None:
    """Launch GUI applications, using tmux."""

    subprocess.run(f"tmux new-session -d -s {session}", shell=True)
    sleep(0.1)
    subprocess.run(f"tmux send-keys -t {session} \"nohup {command} >/dev/null 2>&1 & disown && exit\" enter", shell=True)

def launch_tui(command: str) -> None:
    """Launch TUI application in a terminal and exit when quitting the TUI."""

    subprocess.run(f"{command}", shell=True)

def stay_in_terminal(session: str, command: str) -> None:
    """Execute a command in a tmux session, in order to remain in the terminal."""

    if os.getenv('TMUX'):
        subprocess.run(command, shell=True)
    else:
        subprocess.run(f"tmux new-session -d -s {session}", shell=True)
        sleep(0.1)
        subprocess.run(f'''tmux send-keys -t {session} "{command}" enter''', shell=True)
        subprocess.run(f"env TERM=screen-256color tmux -u a -t '{session}'", shell=True)

def main():

    parser = argparse.ArgumentParser(description="ael-menu")

    parser.add_argument(
        "--documentation",
        action="store_true",
        help="Show detailed documentation and exit."
    )

    args = parser.parse_args()

    if args.documentation:
        show_documentation()

    else:

        options = generate_options()

        entries = ''.join([f"{o.name:<30}{o.description}\n" for o in options]).encode('UTF-8')

        selection = run_menu(entries=entries)

        if selection:
            selected_option = next((o for o in options if o.name == selection), None)
        else:
            print("No selection made. Exiting.", file=sys.stderr)
            sys.exit(1)

        if not selected_option:
            print(f"Error: Selection '{selection}' not found.", file=sys.stderr)
            sys.exit(1)

        command = selected_option.cmd
        session = f"{selected_option.session}{random.randint(0, 10000)}"
        # :[todo] floating.
        # if selected_option.is_floating is True and DESKTOP != "Hyprland":
            # add_float = f'''&& sleep 0.05 && i3-msg "[id=$(xdotool getactivewindow)] floating enable, resize set 800px 500px, move position center"'''

        # :-( EXECUTE )
        if selected_option.run == 'execute':
            execute(command=command)

        # :-( GUI )
        elif selected_option.run == "launch_gui":
            launch_gui(session=session, command=command)

        # :-( TUI )
        elif selected_option.run == 'launch_tui':
            launch_tui(command=command)

        # :-( STAY IN TERMINAL )
        elif selected_option.run == 'stay_in_terminal':
            stay_in_terminal(session=session, command=command)

if __name__ == '__main__':
    main()
