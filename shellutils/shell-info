#!/usr/bin/env bash
# ------------------------------------------------------------------------ INFO
# [/.ael/shellutils/shell-info]
# author        : Pascal Malouin @https://github.com/alterEGO-Linux
# created       : 2023-08-02 01:18:13 UTC
# updated       : 2026-01-05 10:25:41 UTC
# description   : Show shell info.

[ -n "${__SOURCED_SHELL_INFO:-}" ] && return
__SOURCED_SHELL_INFO=1

shell-info() {

    local __args_input=("${@}")
    local __name
    local __type
    local __source
    local __blue=$'\033[34m'
    local __red=$'\033[31m'
    local __reset=$'\033[0m'

    trap '
        #[[ -n ${__dumpfile-} ]] && rm -f -- "$__dumpfile"
        unset -f determine_type \
                  display_alias \
                  display_builtin \
                  display_function \
                  display_keyword \
                  display_variable \
                  show_sourced \
                  show_sourced_tree \
                  show_all \
                  usage; trap - RETURN' RETURN


    # --- setting up temporary file.
    local __tempdir
    if [[ -d /tmp && -w /tmp && -x /tmp ]]; then
        __tempdir=/tmp
    else
        __tempdir="$HOME/tmp"
        mkdir -p -- "$__tempdir" || return 1
    fi

    local __dumpfile="${__tempdir}/sourced_by_shell"

    # --- generating sourced files file.    
    PS4='+ ${BASH_SOURCE[0]}:${LINENO}: ' BASH_XTRACEFD=7 \
    /bin/bash -lx 7> ${__dumpfile} -c 'exit' >/dev/null 2>&1

    determine_type() {
        local _name
        local _type
        for _name in "${__args_input[@]}"; do
            if _type=$(type -t -- "${_name}"); then
                case "${_type}" in
                    alias )
                        __name="${_name}"
                        __type="${_type}"
                        display_alias
                        ;;
                    builtin )
                        __name="${_name}"
                        __type="${_type}"
                        display_builtin
                        ;;
                    function ) 
                        __name="${_name}"
                        __type="${_type}"
                        display_function
                        ;;
                    # builtin )
                        # __name="${_name}"
                        # __type="${_type}"
                        # display_builtin
                        # ;;
                    keyword )
                        __name="${_name}"
                        __type="${_type}"
                        display_keyword
                        ;;
                    *) printf '%s\n' "${__red}[!]${__reset} Nothing found for ${_name}" ;;
                esac
            else
                # --- verify if a variable.
                if [[ -v ${_name} ]]; then
                    __name="${_name}"
                    __type="variable"
                    display_variable
                else
                    printf '%s\n' "${__red}[!]${__reset} Nothing found for ${_name}"
                fi
            fi
        done
    }

    # --- [ alias ]
    display_alias() {
        
        local __from_dumpfile="$(tac ${__dumpfile} | grep -m1 -E "alias .${__name}")"

        if [[ $__from_dumpfile =~ ^[+[:space:]]*([^:]+):([0-9]+):[[:space:]]*alias[[:space:]]+(.+)$ ]]; then
            __source="found in ${BASH_REMATCH[1]} at line ${BASH_REMATCH[2]}."
        fi

        cat <<EOF
===============================================================================
${__blue}[+]${__reset} shell-info - ${__name}
===============================================================================

NAME   : ${__name}
TYPE   : ${__type}
SOURCE : ${__source}

$(alias -- ${__name} 2>/dev/null)
===============================================================================
EOF
    }

    # --- [ builtin ]
    display_builtin() {
        
        cat <<EOF
===============================================================================
${__blue}[+]${__reset} shell-info - ${__name}
===============================================================================

NAME   : ${__name}
TYPE   : ${__type}

$(help -d ${__name})
===============================================================================
EOF
    }

    # --- [ function ]
    display_function() {

        __source=$(shopt -s extdebug; \
                 declare -F ${__name} \
                 | sed -E 's/^([^ ]+) ([0-9]+) (.*)$/found in \3 at line \2./'; \
                 shopt -u extdebug)

        cat <<EOF
===============================================================================
${__blue}[+]${__reset} shell-info - ${__name}
===============================================================================

NAME   : ${__name}
TYPE   : ${__type}
SOURCE : ${__source}

$(declare -f ${__name})
===============================================================================
EOF
    }

    # --- [ keyword ]
    display_keyword() {
        cat <<EOF
===============================================================================
${__blue}[+]${__reset} shell-info - ${__name}
===============================================================================

NAME   : ${__name}
TYPE   : ${__type}

$(help -d ${__name})
===============================================================================
EOF
    }

    # --- [ variable ]
    display_variable() {
        
        local __from_dumpfile="$(tac ${__dumpfile} | grep -m1 -E ":\s${__name}=")"

        if [[ $__from_dumpfile =~ ^[+[:space:]]*([^:]+):([0-9]+):[[:space:]]*${__name}(.+)$ ]]; then
            __source="found in ${BASH_REMATCH[1]} at line ${BASH_REMATCH[2]}."
        fi

        cat <<EOF
===============================================================================
${__blue}[+]${__reset} shell-info - ${__name}
===============================================================================

NAME   : ${__name}
TYPE   : ${__type}
SOURCE : ${__source}

${__name}="$(printf '%s\n' "${!__name}")"
===============================================================================
EOF
    }

    # --- [ fzf ]
    show_all() {

        # --- building arrays.

        local A_ALIASES
        local A_BUILTIN
        local A_FUNCS
        local A_KEYWORD
        local A_VARS

        mapfile -t A_ALIASES< <(compgen -a)
        mapfile -t A_BUILTIN< <(compgen -b)
        mapfile -t A_FUNCS  < <(compgen -A function)
        mapfile -t A_KEYWORD< <(compgen -k)
        mapfile -t A_VARS   < <(compgen -v)

        local _tagged=()
        local x

        # --- [ alias ]
        for x in "${A_ALIASES[@]}"; do
            _tagged+=("( alias ) ${x}")
        done
        # --- [ builtin ]
        for x in "${A_BUILTIN[@]}"; do
            _tagged+=("( builtin ) ${x}")
        done
        # --- [ functions ]
        for x in "${A_FUNCS[@]}"; do
            _tagged+=("( function ) ${x}")
        done
        # --- [ keyword ]
        for x in "${A_KEYWORD[@]}"; do
            _tagged+=("( keyword ) ${x}")
        done
        # --- [ variable ]
        for x in "${A_VARS[@]}"; do
            _tagged+=("( variable ) ${x}")
        done

        local _selection
        _selection="$(printf '%s\n' "${_tagged[@]}" | ael-fzf)"
        [[ -z "${_selection}" ]] && return 1

        local _name
        local _type
        _type="${_selection%% \)*}"; _type="${_type#\( }"
        _name="${_selection#* \) }"

        case "${_type}" in
            alias)
                __name="${_name}"
                __type="${_type}"
                display_alias
                ;;
            builtin)
                __name="${_name}"
                __type="${_type}"
                display_builtin
                ;;
            function) 
                __name="${_name}"
                __type="${_type}"
                display_function
                ;;
            keyword)
                __name="${_name}"
                __type="${_type}"
                display_keyword
                ;;
            variable)
                __name="${_name}"
                __type="${_type}"
                display_variable
                ;;
        esac
    }

    # --- [ sourced ]
    show_sourced() {
        sed -nE 's/^[+[:space:]]*[^:]+:[0-9]+:[[:space:]]+(source|\.)[[:space:]]+(.+)$/\2/p' -- "$__dumpfile"
    }

    # --- [ sourced tree ]
    show_sourced_tree() {
        awk -v OFS='' '
            # --- trim helpers
            function ltrim(s){sub(/^[ \t\r\n]+/,"",s);return s}
            function rtrim(s){sub(/[ \t\r\n]+$/,"",s);return s}
            function trim(s){return rtrim(ltrim(s))}

            # --- collect only lines that are "source ..." or ". ..." from xtrace:
            # ... ++++ /path/to/file:LINE: source TARGET...
            {
              line = $0
              if (match(line, /^([+]+)[[:space:]]*([^:]+):([0-9]+):[[:space:]]+(source|\.)[[:space:]]+(.*)$/, m)) {
                n++
                depth[n]  = length(m[1])         # --- number of '+' = nesting depth
                target[n] = trim(m[5])           # --- what was sourced (as seen)
              }
            }

            END {
              # --- determine if each node is the last sibling at its depth.
              for (i=1; i<=n; i++) {
                last[i] = 1
                for (j=i+1; j<=n; j++) {
                  if (depth[j] <= depth[i]) {
                    if (depth[j] == depth[i]) last[i] = 0
                    break
                  }
                }
              }

              # --- active vertical bars per depth (for nice tree branches).
              for (l=1; l<=256; l++) active[l]=0
              prevd = 0

              for (i=1; i<=n; i++) {
                d = depth[i]

                # --- clear deeper actives when we move up the tree.
                for (l=prevd; l>d; l--) active[l]=0

                # --- build ancestor prefix: │  if future siblings remain, else spaces.
                prefix = ""
                for (l=1; l<d; l++) prefix = prefix (active[l] ? "│  " : "   ")

                # --- connector for this node.
                connector = (last[i] ? "└─ " : "├─ ")

                print prefix, connector, target[i]

                # --- update active bar for this depth
                active[d] = last[i] ? 0 : 1
                prevd = d
              }
            }
          ' "$__dumpfile"
    }

    # --- [ help ]
    usage() {
        cat <<EOF
===============================================================================
[+] shell-info - Show shell info.
===============================================================================
Usage: shell-info [--fzf|--sourced|--sourced-tree|-h|--help] [NAME]

Options:
  --fzf            Open the interactive selector (default if no args)
  --sourced        List files sourced during startup
  --sourced-tree   Tree view of sourced files (based on + depth)
  -h, --help       Show this help and exit

Will return the name, type and if available, the source of current shell
variable, alias, function, builtin or keyword.

For alias, variable and function, the code itself will be displayed.

For builtin and keyword, a short description will be diplayed.

Example:
  shell-info tmuxplus
===============================================================================
EOF
    }

    # ---------- [ argument parser ]

    # --- no arguments.
    if [[ $# == 0 ]]; then __args_input=("--fzf"); fi

    local i
    # --- show help and ignore other arguments.
    for i in "${__args_input[@]}"; do
        if [[ "${i}" == "-h" || "${i}" == "--help" ]]; then usage; return 0; fi
    done

    # --- execute --fzf and ignore other arguments. 
    for i in "${__args_input[@]}"; do
        if [[ "${i}" == "--fzf" ]]; then show_all; return 0; fi
    done

    # --- execute --sourced and ignore other arguments. 
    for i in "${__args_input[@]}"; do
        if [[ "${i}" == "--sourced" ]]; then show_sourced; return 0; fi
    done

    # --- execute --sourced-tree and ignore other arguments. 
    for i in "${__args_input[@]}"; do
        if [[ "${i}" == "--sourced-tree" ]]; then show_sourced_tree; return 0; fi
    done

    determine_type
    return 0
}
